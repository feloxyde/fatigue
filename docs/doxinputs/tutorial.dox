/** @page Tutorial Tutorial 

@section Installing

@section quick_example Quick example

@subsection writing_tests Writing tests

Let's assume we want to test a really simple code computing average value of a vector of floats. 

~~~{.cpp}
float avg(std::vector<float> const& v){
    if(v.empty()){
        return 0.0;
    }
    
    float sum = 0.0;
    for(auto const& f : v)  {
        sum += f;
    }

    return sum/v.size();
}
~~~

We will want to have three test cases : 

- empty vector 
- one element 
- multiple element

Let's start with empty vector test. For this, we will create a ```Empty``` test case by publicly deriving from 
```ftg::Test``` class : 

~~~{.cpp}
#include <fatigue/Test.hpp> //inclusion of Test definition
//also, including our ```avg``` function header and so on. 

class Empty : public ftg::Test { 
    /* implement test here */
};
~~~

We need to define at least three things for the test : 
- a constructor calling ```Test``` constructor, passing the name of the test.
- a virtual destructor, which in our case can be empty.
- a virtual ```void run()``` method, which is the scenario of our test. 

~~~{.cpp}
class Empty : public ftg::Test { 
    Empty() : ftg::Test("Empty"){}
    virtual ~Empty(){};

    virtual void run() {
        std::vector<float> f; //empty vector
        check_equal(f.size(), 0); //checking vector is empty
        check_equal(avg(f), 0.0); //checking our function
    }
};
~~~

We use ```check_*``` methods, provided by class ```ftg::Test```, verify results. Checks are counted and reported. We will discuss them a bit later, and they are listed in @ref checks "Checks" page.
Let's write two more tests, for the two other cases.

~~~{.cpp}
class OneElement : public ftg::Test { 
    OneElement() : ftg::Test("OneElement"){}
    virtual ~OneElement(){};

    virtual void run() {
        std::vector<float> f; //empty vector
        f.push_back(1.0);
        check_equal(f.size(), 1); //checking vector has one element
        check_equal(avg(f), 1.0); //checking our function
    }
};

class MultipleElements : public ftg::Test { 
    MultipleElements() : ftg::Test("MultipleElements"){}
    virtual ~MultipleElements(){};

    virtual void run() {
        std::vector<float> f; //empty vector
        f.push_back(1.0);
        f.push_back(2.0);
        f.push_back(3.0);
        f.push_back(4.0);
        check_equal(f.size(), 4); //checking vector has four elements
        check_equal(avg(f), 2.5); //checking our function
    }
};
~~~

@subsection writing_suite Writing suite 

Let's do as if we were to have thousands of tests for a lot of different classes and function, and thus group tests 
for our ```avg``` function together. For that we use a suite. In fatigue, writing a suite ressembles a lot writing a test. 

We implement a suite by publicly deriving from ```ftg::Suite```, and then implement : 
- A constructor, calling ```ftg::Suite``` constructor and giving it a name.
- A virtual destructor, which can be empty in our case. 
- A virtual ```TestList tests()``` method, that will simply return a list of tests in the suite. Note that suites are recursively defined, and thus can contain other suites.

~~~{.cpp}
#include <fatigue/Suite.hpp>
#include <memory> //for unique ptrs

class Avg : public ftg::Suite {
    Avg() : ftg::Suite("Avg") {}
    virtual ~Avg();

    virtual ftg::TestList tests() {
        ftg::TestList tl;
        tl.push_back(std::make_unique<Empty>());
        tl.push_back(std::make_unique<OneElement>());
        tl.push_back(std::make_unique<MultipleElements>());
        return tl;
    }
};
~~~

You can notice that here, we use suites as a namespace for our tests as well, calling our test ```Empty``` instead of ```TestAvgEmpty``` for example. 
This is not mandatory, and if you prefer full explicit names, that is up to you.  

@subsection writing_test_software Writing test software

Finally, we want to create an executable running our tests. For this, ```fatigue``` class is convenient. We can use it in three steps, preferably inside a ```main``` function.

- Create a ```fatigue``` instance by initializing it with ```main``` invocation args, ```argc``` and ```argv```.
- Declare a certain number of tests or suites, using ```declare``` method.
- Run tests using ```run``` method, and return the result as the return code of the program.

~~~{.cpp}
#include <fatigue/fatigue.hpp>


int main(int argc, char** argv){

    auto f = ftg::fatigue(argc, argv);
    f.declare(std::make_unique<Avg>());
    return f.run();

}
~~~

Run method returns the number of tests that failed, and 0 if all tests passed.

Note that ```declare``` method supports method chaining, allowing more flexibility in declaration of tests. 

~~~{.cpp}
int main(int argc, char** argv){

    return ftg::fatigue(argc, argv)
           .declare(std::make_unique<Avg>());
           .run();

}
~~~

@subsection building_test_software Building test software

Now, we can simply compile test software and link it with ```fatigue``` library. In CMake, it looks like this : 

~~~{.cmake}
add_executable(tests tests.cpp)
target_link_libraries(tests fatigue)
~~~

@section tutorial_checks Checks

@subsection tutorial_checks_basics Basics

When writing tests, we use *checks* provided by the ```ftg::Test``` class, allowing us to specify conditions for 
test success and cleaner failure reporting. All checks are listed in the @ref checks "Checks" page. Let's see the overall anatomy and usage of checks. 
All checks methods are of the form :

~~~{.cpp}
check_*(argument [, argument]); //check with default message
check_*(argument [, argument], message); //check with custom message 
~~~

When using default message, check will report value, type and name of its arguments. For example, 

~~~{.cpp}
check_equal(1.0f, 2);  
~~~

Will report that *l* (left) argument, *float*, with value *1.0*, was not equal to *r* (right) argument, *int*, with value *2*. 

To convert value to string, checks use ```ftg::to_string(T const& val)``` template function. By default, this function tries to 
use the ```std::ostream``` shift operator ```<<```, but can be specialized to allow more refined display of values. 

In case values are maybe too hard to display, one may eventually use custom message check, which will not report any information regarding its arguments. 

@subsection tutorial_checks_options Options

There are several options that can alter behavior of a check. If we look at the prototype of a check, we can see that it returns ```ftg::Check``` instance. 
This instance allows use, through method chaining, to give more precision about what is the check. Please refer to the documentation of the class for better understanding. 

Because of this option mechanism, Check objects shall NEVER be assigned to a variable, in order to use discarded-value-expression mechanism. See @ref architecture_reporting "Reporting mechanisms" section in @ref Architecture "Architecture" page for more information.

@section advanced_testing Advanced testing

@section tutorial_cli Command line interface

@subsection tutorial_runners Runners

@section extending Extending fatigue

As Fatigue is an open source software, you can easily adapt its sources to your needs. *I try to provide sufficient documentation to do so as well*. However, that is in most cases what you want to do, since it can create conflicts with future updates. You probably prefer to *extend* fatigue instead of changing its core behavior. This section constains some tips on how to do that.

@subsection tutorial_extending_checks Create custom checks

We may want to extend checking capabilities, as for example adding a check to verify if a value is equal to ten. For this, we have to create a new ```TenTest``` class shall inherit from ```ftg::Test```, and will probably looks as follows : 

~~~{.cpp}

class TenTest : public ftg::Test {
//here public constructor, virtual dtor and other stuff.

protected: 
    //our check. Better be it protected scope since we will only access it 
    //in run() method of tests deriving from TenTest.
    
    template<ToStringable T>
    Check check_equals_ten(T const& value);
};
~~~

```ToStringable``` concept ensures that ```T``` is convertible to string using ```ftg::to_string``` template function described earlier in this tutorial.

The method's body will look more or less like this : 

~~~{.cpp}

template<ToStringable T>
Check check_equals_ten(T const& value)
{
std::vector<ParamInfo> params;
params.emplace_back("value", ftg::to_string(value), type_to_string<T>());
return raw_check("check_near_equal",
                 params,
                 value == 10);
}
~~~

Our check returns a ```ftg::Check``` object. Checking mechanisms are detailed in @ref architecture_reporting "Reporting mechanisms" section in @ref Architecture "Architecture" page. This is not mandatory to understand what is going on there to extend fatigue, even if it can help. We can not create a ```Check``` object directly, and instead we call ```raw_check``` method from ```ftg::Checker```, accessible through inheriting from ```ftg::Test```. 

```raw_check``` method takes three arguments, which you can consult in detail on ```ftg::Check``` page : 

- name of the check performed
- list of arguments of the check, their types and their names.
- a boolean being the actual result of the check performed.

And we are done, our check is now ready to be used ! 

@subsection tutorial_extending_runners Creating custom runner

*TO BE ADDED*


@subsection tutorial_extending_cli Adding CLI options 

*more of a trick to add new configs by simply reparsing options, eventually wrapping ```fatigue``` object. WILL NEED AN OPTION TO ADD CUSTOM RUNNERS*

*/