/** @page tutorial Tutorial 

@section Installing

@section quick_example Quick example

@subsection writing_tests Writing tests

Let's assume we want to test a really simple code computing average value of a vector of floats. 

\include quick_example/avg.hpp

We will want to have three test cases : 

- empty vector 
- one element 
- multiple element

Let's start with empty vector test. For this, we will create a ```Empty``` test case by publicly deriving from 
```ftg::Test``` class.

We need to define at least three things for the test : 
- a constructor calling ```Test``` constructor, passing the name of the test.
- a virtual destructor, which in our case can be empty.
- a virtual ```void run()``` method, which is the scenario of our test. 

\include quick_example/TestAvgEmpty.hpp

We use ```check_*``` methods, provided by class ```ftg::Test```, verify results. Checks are counted and reported. We will discuss them a bit later, and they are listed in @ref checks "Checks" page.
Let's write two more tests, for the two other cases.

\include quick_example/TestAvgOne.hpp

\include quick_example/TestAvgMany.hpp

@subsection writing_suite Writing suite 

Let's do as if we were to have thousands of tests for a lot of different classes and function, and thus group tests 
for our ```avg``` function together. For that we use a suite. In fatigue, writing a suite ressembles a lot writing a test. 

We implement a suite by publicly deriving from ```ftg::Suite```, and then implement : 
- A constructor, calling ```ftg::Suite``` constructor and giving it a name.
- A virtual destructor, which can be empty in our case. 
- A virtual ```TestList tests()``` method, that will simply return a list of tests in the suite. Note that suites are recursively defined, and thus can contain other suites.

\include quick_example/SuiteAvg.hpp

You can notice that here, we use suites as a namespace for our tests as well, calling our test ```Empty``` instead of ```TestAvgEmpty``` for example. 
This is not mandatory, and if you prefer full explicit names, that is up to you.  

@subsection writing_test_software Writing test software

Finally, we want to create an executable running our tests. For this, ```fatigue``` class is convenient. We can use it in three steps, preferably inside a ```main``` function.

- Create a ```fatigue``` instance by initializing it with ```main``` invocation args, ```argc``` and ```argv```.
- Declare a certain number of tests or suites, using ```declare``` method.
- Run tests using ```run``` method, and return the result as the return code of the program.

\include quick_example/main_avg.cpp

Run method returns the number of tests that failed, and 0 if all tests passed.

Note that ```declare``` method supports method chaining, allowing more flexibility in declaration of tests. 

\include quick_example/main_avg_chaining.cpp

@subsection building_test_software Building test software

Now, we can simply compile test software and link it with ```fatigue``` library. In CMake, it looks like this : 

~~~{.cmake}
add_executable(test_tutorial_avg quick_example/main_avg.cpp)
target_link_libraries(test_fatigue fatigue)
~~~

@section tutorial_checks Checks

@subsection tutorial_checks_basics Basics

When writing tests, we use *checks* provided by the ```ftg::Test``` class, allowing us to specify conditions for 
test success and cleaner failure reporting. All checks are listed in the @ref checks "Checks" page. Let's see the overall anatomy and usage of checks. 
All checks methods are of the form :

~~~{.cpp}
/* check with default message */
check_*(argument [, argument]); 
/* check with custom message */
check_*(argument [, argument], message);  
/* check with custom message and parameter informations */
check_*(argument [, argument], message, vector<paramInfo>);
~~~

When using default message, check will report value, type and name of its arguments. For example, 

~~~{.cpp}
check_equal(1.0f, 2);  
~~~

Will report that *l* (left) argument, *float*, with value *1.0*, was not equal to *r* (right) argument, *int*, with value *2*. 

To convert value to string, checks use ```ftg::to_string(T const& val)``` template function. By default, this function tries to 
use the ```std::ostream``` shift operator ```<<```, but can be specialized to allow more refined display of values. 

In case values are maybe too hard to display, one may eventually use custom message check, which will not report any information regarding its arguments. 

@subsection tutorial_checks_options Options

There are several options that can alter behavior of a check. If we look at the prototype of a check, we can see that it returns ```ftg::Check``` instance. 
This instance allows use, through method chaining, to give more precision about what is the check. Please refer to the documentation of the class for better understanding. 

Because of this option mechanism, Check objects shall NEVER be assigned to a variable, in order to use discarded-value-expression mechanism. See @ref architecture_reporting "Reporting mechanisms" section in @ref architecture "Architecture" page for more information.

How checks are displayed depend on the runner chosen, however, it is likely that they will be reported by their index of appearance in the test. For example, 

~~~{.cpp}
check_true(true);
check_true(false); //this will be reported as check nÂ°2
~~~

@section tutorial_cli Command line interface

@subsection tutorial_runners Runners

@section advanced_testing Advanced testing

@section tutorial_fixtures Fixtures

@section tutorial_heavy_tests Heavy resources tests



@section extending Extending fatigue

As Fatigue is an open source software, you can easily adapt its sources to your needs. *I try to provide sufficient documentation to do so as well*. However, that is in most cases what you want to do, since it can create conflicts with future updates. You probably prefer to *extend* fatigue instead of changing its core behavior. This section constains some tips on how to do that.

@subsection tutorial_extending_checks Create custom checks

We may want to extend checking capabilities, as for example adding a check to verify if a value is equal to ten. For this, we have to create a new ```TenTest``` class shall inherit from ```ftg::Test```, and will probably looks as follows : 

\include extending/TenTest.hpp

```ToStringable``` concept ensures that ```T``` is convertible to string using ```ftg::to_string``` template function described earlier in this tutorial.

Our check returns a ```ftg::Check``` object. Checking mechanisms are detailed in @ref architecture_reporting "Reporting mechanisms" section in @ref architecture "Architecture" page. This is not mandatory to understand what is going on there to extend fatigue, even if it can help. We can not create a ```Check``` object directly, and instead we call ```raw_check``` method from ```ftg::Checker```, accessible through inheriting from ```ftg::Test```. 

```raw_check``` method takes three arguments, which you can consult in detail on ```ftg::Check``` page : 

- name of the check performed
- list of arguments of the check, their types and their names.
- a boolean being the actual result of the check performed.

And we are done, our check is now ready to be used ! 

@subsection tutorial_extending_runners Creating custom runner

Builtin runners should be sufficient for most use, but in case you want to create your custom runners, it is always possible. *Still, be careful, runners can be trickier than you think, since fatigue's core isn't thought to be intuitive, but rather flexible and practical to implement.

General thoughts on runners and loggers are described in @ref architecture_run "Test runners and loggers" section of @ref architecture "Architecture" page. It is recommended for you to read this section to better understand what follows.

As an example, here is the code of an absolutely minimal combined runner and logger, providing no output and exiting straight with an error code in case a test 
fails. It considers any check not passing as an error.

\include extending/TrivialRunner.hpp

Now, we want to see how to use our runner. This will be seen in section @ref tutorial_extending_cli "Using and adding CLI options".

@subsection tutorial_extending_cli Using and adding CLI options 

As mentionned before, fatigue allows user to alter behavior of the test software through command lines options. Options are parsed using [jarro2783's cxxopts library](https://github.com/jarro2783/cxxopts).

Now, how to add options. In this example, we will add the custom runner we made in section @ref tutorial_extending_runners "Creating custom runner" in the runner pool, as well as an option to select the fastest available runner (that we assume to be our ```TrivialRunner```).


First, we write a function taking in a ```cxxopts::Option``` reference.

\include extending/customOptions.hpp

Then, we need to register options to ```ftg::fatigue``` class, through the constructor accepting a vector of ```ftg::fatigue::OptionsDeclarer```. As this constructor is protected, we will have to derive from ```ftg::fatigue``` class.

\include extending/fatigue_ex.hpp

We can now use ```fatigue_ex``` as a drop-in replacement for  ```fatigue``` :

\include extending/main_ex.cpp

And of course, we can use ```-f``` or ```--fast``` option in the command line. 

*/